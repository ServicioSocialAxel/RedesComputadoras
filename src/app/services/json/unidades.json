[
  {
    "indice": 1,
    "titulo": "Fundamentos de redes",
    "imagen": "https://i.go-travels.com/img/how-to/networking-fundamentals.jpg",
    "competencia": "Analiza los fundamentos de redes de computadoras con base en su clasificación, organizaciones de estandarización, el modelo OSI, la arquitectura TCP/IP.",
    "keywords": ["Redes", "Clasificación", "Estandares", "OSI", "TCP/IP"],
    "contenido": [
      {
        "seccion": 1.1,
        "titulo": "Fundamentos de redes de computadoras",
        "descripcionRecurso": "",
        "keywords": ["Redes", "Fundamentos"],
        "unidad": "<h3 class='text-center'>Sección sin información</h3>",
        "recurso": "",
        "actividad": "<div class='embed-responsive embed-responsive-16by9 diapos'><object data='https://www.dspace.espol.edu.ec/bitstream/123456789/27398/1/20132SPRTCO011561_1.PDF' type='application/pdf'></object></div>"
      },
      {
        "seccion": 1.2,
        "titulo": "Clasificación de redes de computadoras",
        "descripcionRecurso": "",
        "keywords": ["Clasificacion", "Geográfica", "Tendencias"],
        "unidad": "<h3 class='text-center'>Sección sin información</h3>",
        "recurso": "",
        "actividad": "<h3 class='text-center'>Sin actividades disponibles</h3>"
      },
      {
        "seccion": 1.3,
        "titulo": "Organizaciones de estandarización",
        "descripcionRecurso": "",
        "keywords": ["Estandares", "IEEE"],
        "unidad": "Test",
        "recurso": "",
        "actividad": "<h3 class='text-center'>Sin actividades disponibles</h3>"
      },
      {
        "seccion": 1.4,
        "titulo": "Modelo OSI y Arquitectura TCP/IP",
        "descripcionRecurso": "",
        "keywords": ["OSI", "TCP/IP"],
        "unidad": "<h3 class='text-center'>Sección sin información</h3>",
        "recurso": "",
        "actividad": "<h3 class='text-center'>Sin actividades disponibles</h3>"
      }
    ]
  },
  {
    "indice": 2,
    "titulo": "Transmisión de datos",
    "imagen": "https://x.utel.edu.mx/repositorios/uploads/2020/03/L1Is113.jpg",
    "competencia": "Analiza los mecanismos de transmisión de datos que garantizan una comunicación confiable con base en las funciones de los protocolos, especificaciones y estándares de medios de transmisión.",
    "keywords": [
      "Protocolos",
      "Encapsulamiento",
      "Transmisión",
      "Multiplexación",
      "Control de errores",
      "Segmentación"
    ],
    "contenido": [
      {
        "seccion": 2.1,
        "titulo": "Funciones de los protocolos",
        "descripcionRecurso": "",
        "keywords": ["Redes", "Fundamentos"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 2.2,
        "titulo": "Especificaciones y estándares de medios de transmisión",
        "descripcionRecurso": "",
        "keywords": ["Medios", "Transmisión"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 2.3,
        "titulo": "Códigos de línea",
        "descripcionRecurso": "",
        "keywords": ["Código"],
        "unidad": "",
        "recurso": ""
      }
    ]
  },
  {
    "indice": 3,
    "titulo": "Capa de Acceso a la Red",
    "imagen": "https://www.legalik.com/i/wi/abogados-acceso-a-red-no-autorizada-espionaje-y-robo-de-informacion.1280x960.1493543501.jpeg",
    "competencia": "Examina la capa de acceso a la red a partir de rutinas para manipular la NIC, estándares aplicables y tecnologías de control de acceso al medio.",
    "keywords": ["Capa Física", "NIC", "Rutinas", "IEE 802.3", "Accesos"],
    "cuadroEval": "assets/img/bibliografia.png",
    "contenido": [
      {
        "seccion": 3.1,
        "titulo": "Fundamentos de capa física",
        "descripcionRecurso": "",
        "keywords": ["Ancho de banda", "Ruido"],
        "unidad": "<section id='contenido-31'> <section id='contenido-31__311'> <p></p> <h4>3.1.1 Ancho de banda</h4> <strong>Ancho de banda analógico</strong>: Consiste en el rango de frecuencias alrededor de la frecuencia fundamental y donde se concentra la mayor cantidad de energía de la señal. Se mide en hercios (Hz). En este rango de frecuencias positivas la respuesta del sistema es relativamente plana, por lo que las señales pueden ser transmitidas sin distorsión. <p /> <figure style='text-align: center'> <img src='assets/img/3_1_Contenido.png' alt='' style='width: 75rem; margin: 2rem auto' /> <figcaption> Stallings W. (2004). Transmisi&oacute;n de datos. En comunicaci&oacute;n y redes de computadoras. (pp. 95). USA: Pearson Education </figcaption> </figure> <br /> <p> <strong>Ancho de banda digital</strong>: Normalmente asociado con la Capacidad de canal (C), se define como la máxima cantidad de información (bits) que puede ser enviada por unidad de tiempo sobre un canal de comunicación. Se mide en bits por segundo (bps). </p> </section> <br /> <section id='contenido-31__312'> <h4>3.1.2 Ruido y relación señal-ruido</h4> <p> <strong>Ruido</strong>: Son señales no deseadas que se añaden a la señal de datos durante la transmisión a través del medio de comunicación. De acuerdo con (Stallings, 2004), el ruido puede clasificarse en: </p> <ul> <li> <p> <strong>Ruido térmico</strong> (ruido blanco): está presente en todos los dispositivos electrónicos y medios de transmisión, no se puede eliminar y supone un límite superior en las prestaciones de los dispositivos de comunicación. Se debe a la agitación térmica producida por los electrones. </p> <br /> <p style='text-align: center'> <img style='margin: 0 auto' src='assets/img/contenido-31-312-eq1.png' alt='' /> </p> </li> <br /> <li> <strong>Ruido de intermodulación</strong>: Se produce cuando dos o más señales a diferentes frecuencias usan el mismo medio de transmisión y éstas se suman produciendo señales a múltiplos de las frecuencias originales. Debido a un mal funcionamiento del transmisor, receptor, o el medio. </li> <br /> <li> <strong>Diafonía</strong>: Se debe al acoplamiento de dos señales de transmisión haciendo que se mezclen ambas señales. Es menos frecuente en transmisiones por aire que por cable. </li> <br /> <li> <strong>Ruido impulsivo</strong>: Éste se debe a diversos motivos (tormentas atmosféricas que causan perturbaciones electromagnéticas, medios de transmisión en mal estado, etc.). </li> </ul> <br /> <p> <strong>Relación Señal/Ruido (S/N)</strong>: Expresa la cantidad en que una señal de información excede el nivel de ruido presente en el medio de comunicación. </p> <br /> <p style='text-align: center'> <img style='margin: 0 auto' src='assets/img/contenido-31-312-eq2.png' alt='' /> </p> </section> <br /> <section id='contenido-31__313'> <p> <strong>3.1.3 Capacidad de Canal (C)</strong>: Esta medida fija el límite teórico al cual los datos pueden ser transmitidos por el canal de comunicación. Está definida como la máxima velocidad a la que los datos pueden ser transmitidos con buena fidelidad (baja tasa de errores) sobre un canal de comunicación. Se mide en bits por segundo (bps). Existen dos criterios importantes para medir la capacidad de canal, el de Nyquist (caso ideal) y el de Shannon: </p> <ul> <li> <p>Capacidad de canal de acuerdo con Nyquist:</p> <br /> <p style='text-align: center'> <img style='margin: 0 auto' src='assets/img/contenido-31-313-eq1.png' alt='' /> </p> </li> <br /> <li> <p>Capacidad de canal de acuerdo con Shannon:</p> <br /> <p style='text-align: center'> <img style='margin: 0 auto' src='assets/img/contenido-31-313-eq2.png' alt='' /> </p> </li> </ul> </section> </section>",
        "recurso": "<h4>Fundamentos de la capa f&iacute;sica</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='assets/data/3_1_FundamentosDeCapaFisica.pdf' type='application/pdf' ></object> </div> <br /> <br /> <h4 class='pt-5'>Ejemplos resueltos del tema</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='assets/data/3_1_EjemplosResueltosTema.pdf' type='application/pdf' ></object> </div> <br /> <br />"
      },
      {
        "seccion": 3.2,
        "titulo": "Rutinas para manipular la NIC",
        "descripcionRecurso": "Lista de códigos para la NIC tanto en C, como en Java",
        "keywords": ["Tramas de vuelo", "Enviar Tramas", "Rutinas"],
        "unidad": "<section class='contenido'> <section> <p class='descripcion'> A continuación, se describirá el uso de rutinas basadas en las bibliotecas PCAP4J (lenguaje JAVA) y NPCAP (lenguaje C) para acceder al controlador de la tarjeta de red y poder realizar captura de tramas de datos. Para poder hacer uso de estas bibliotecas se sugiere lo siguiente: </p> <strong>PCAP4J</strong> <br /><br /> <ul> <li> Para usar la biblioteca PCAP4J se aconseja el uso del Ambiente de Desarrollo Integrado (IDE) Netbeans, el cual puede ser descargado desde la siguiente liga: <a href='https://netbeans.apache.org/'>Netbeans IDE</a> </li> <li> También se aconseja usar el gestor de dependencias Maven para trabajar los proyectos de Netbeans. </li> <li> También se aconseja descargar e instalar el paquete NPCAP, miso que puede ser descargado desde la siguiente liga: <a href='https://npcap.com/'>paquete NPCAP</a> y realizar el proceso de instalación del mismo, sin olvidar que durante el proceso de instalación se deberá seleccionar el recuadro “Modo compatibilidad con Winpcap” cuando éste sea visible en pantalla. </li> <li> Se recomienda tener instalada una versión de JDK en la computadora; de no tenerla, se puede descargar desde aquí: <a href='https://www.oracle.com/java/'>java JDK</a> </li> <li> Ya instalado el JDK y Netbeans, se procede con la configuración de la biblioteca PCAP4J de acuerdo con el siguiente documento: <a href='http://148.204.58.221/axel/redesnp/sniffer/pcap4j/pcap4J_configuraci%f3n.pdf' >configuracion</a > </li> </ul> <br /> <strong>NPCAP</strong> <br /> <br /> <ul> <li> Para usar la biblioteca NPCAP se aconseja primero descargar el instalador desde la siguiente liga: <a href='https://npcap.com/'>https://npcap.com/</a> y realizar el proceso de instalación del mismo, sin olvidar que durante el proceso de instalación se deberá seleccionar el recuadro “Modo compatibilidad con Winpcap” cuando éste sea visible en pantalla. </li> <li> Una vez instalada la biblioteca NPCAP se requiere instalar el compilador DEVC++, mismo que puede ser descargado desde la siguiente liga: <a href='http://148.204.58.221/axel/redesnp/sniffer/NPCAP/Dev-Cpp%205.11%20TDM-GCC%204.9.2%20Setup.exe' >Compilador DevC++</a > </li> <li>Posteriormente seguir las instrucciones para su instalación.</li> </ul> </section> <br /><br /> <section> <p><strong>3.2.1 Rutinas para leer tramas al vuelo</strong></p> <br /> <strong>Desde PCAP4J</strong> <br /><br /> <ul> <li> <p> Primero se debe elegir la interfaz de red que se usará para realizar la captura de tramas. Para ello hacemos uso del método estático org.pcap4j.util.NifSelector.NifSelector(), que a su vez nos permite hacer uso del método selectNetworkInterface( ) tal como se puede ver a continuación para permitir al usuario elegir la interfaz de red a ser utilizada: </p> <pre> <code> &NewLine;PcapNetworkInterface nif; &NewLine;try { &NewLine;&Tab;nif = new NifSelector( ).selectNetworkInterface(); &NewLine;} catch (IOException e) { &NewLine;&Tab;e.printStackTrace( ); &NewLine;&Tab;return; &NewLine;}//catch </code> </pre> </li> <li> <p> Después, debemos configurar el descriptor de la interfaz de red para poder abrirlo en modo promiscuo y así poder capturar todas las tramas que pasen por el medio de transmisión y no solo las dirigidas hacia su dirección MAC. Para la configuración del descriptor es necesario especificar los parámetros: nombre de la NIC, tamaño de trama a ser capturada (SNAPLEN), modo de operación(PROMISCUO), tiempo de lectura por trama (en milisegundos), tamaño de buffer para almacenar los datos de la trama (en bytes). Una vez especificados los parámetros de apertura, se procede a abrir el descriptor con el método build( ). </p> <pre> <code> &NewLine;PcapHandle handle = new PcapHandle.Builder(nif.getName()) &NewLine;&Tab;.snaplen(SNAPLEN) &NewLine;&Tab;.promiscuousMode(PromiscuousMode.PROMISCUOUS) &NewLine;&Tab;.timeoutMillis(READ_TIMEOUT) &NewLine;&Tab;.bufferSize(BUFFER_SIZE) &NewLine;&Tab;.build(); </code> </pre> </li> <li> <p> Posteriormente se crea un filtro de captura (de ser necesario) para especificar el tipo de tramas a ser capturadas, de otro modo se hará una captura por fuerza bruta. El formato del filtro de captura utiliza la misma sintaxis que la aplicación <strong>tcpdump</strong>: </p> <pre> <code> handle.setFilter(filter, BpfCompileMode.OPTIMIZE); </code> </pre> </li> <li> <p> Después se procede a la captura de las tramas, para ello podemos hacer uso del método getNextRawPacket( ) de la instancia handle: </p> <pre> <code> &NewLine;while (true) { &NewLine;&Tab;byte[ ] packet = handle.getNextRawPacket(); </code> </pre> <p> la cual nos devolverá un arreglo de bytes con el contenido de la trama para así poder iniciar con su análisis. En caso de desear capturar múltiples tramas, lo ciclamos en una estructura de iteración (for, o while). </p> </li> <li> <p> Podemos acceder a cada byte de la trama para su posterior análisis: </p> <pre> <code> &NewLine;for(int j=0; j < packet.length; j++ ){ &NewLine;&Tab;System.out.printf(&quot;%02X &quot;,packet[j]); &NewLine;&Tab;if(j % 16 == 0 ) &NewLine;&Tab;System.out.println(&quot;&quot;); &NewLine;}//for </code> </pre> </li> <li> <p> Para ver un ejemplo completo, da click en el siguiente enlace: <a href='http://148.204.58.221/axel/redesnp/sniffer/pcap4j/GetNextRawPacket.java' > GetNextRawPacket.java </a> </p> </li> </ul> <br /> <strong>Desde NPCAP</strong> <br /><br /> <ul> <li> <p> Primero se debe elegir la interfaz de red que se usará para realizar la captura de tramas. Para ello hacemos uso de dos apuntadores de tipo pcap_if_t, uno de ellos apuntará al inicio de una lista de las interfaces de red encontradas en la máquina, el otro será usado para recorrer cada una de las interfaces de la lista: </p> <pre> <code> pcap_if_t *alldevs; &NewLine;pcap_if_t *d; &NewLine;char errbuf[PCAP_ERRBUF_SIZE]; </code> </pre> </li> <li> <p> Posteriormente invocamos a la función pcap_findalldevs(&alldevs,errbuf) para generar el listado de interfaces de red encontradas, mismas que serán referidas por el apuntador alldevs. El segundo parámetro de la función es solo un buffer para que en caso de generarse un error de entrada/salida sea almacenado en él: </p> <pre> <code> if(pcap_findalldevs(&alldevs, errbuf) == -1) { &NewLine;&Tab;fprintf(stderr,&quot;Error in pcap_findalldevs: %s&quot;, errbuf); &NewLine;&Tab;exit(1); &NewLine;} </code> </pre> </li> <li> <p> Una vez que la lista de tarjetas de red está cargada con la información obtenida por la función pcap_findalldevs( ), recorremos la lista y la desplegamos para que el usuario elija la tarjeta desde la cual se hará la captura de tramas: </p> <pre> <code> &NewLine;for(d=alldevs; d; d=d->next) { &NewLine;&Tab;printf(&quot;%d. %s&quot;, ++i, d->name); &NewLine;&Tab;if (d->description) &NewLine;&Tab;&Tab;printf(&quot;(%s)&quot;, d->description); &NewLine;&Tab;else &NewLine;&Tab;&Tab;printf(&quot;(No hay descripción disponible)&quot;); &NewLine;} &NewLine;if(i==0){ &NewLine;&Tab;printf(&quot;No se encontraron interfaces de red! Asegúrate que NPCAP está instalado.&quot;); &NewLine;&Tab;return -1; &NewLine;} &NewLine;printf(&quot;Elige el número de interfaz de captura (1-%d):&quot;,i); &NewLine;scanf(&quot;%d&quot;, &inum); </code> </pre> </li> <li> <p> Recorremos la lista hasta el índice de interfaz elegido por el usuario </p> <pre> <code> for(d=alldevs, i=0; i < inum-1; d=d->next, i++); </code> </pre> </li> <li> <p> Y abrimos el descriptor de la interfaz de red mediante la función pcap_open_live(), en los argumentos de esta función debemos especificar: el nombre del dispositivo, la porción del paquete a ser capturado, modo de apertura (promiscuo para escuchar todos los paquetes que pasen por el medio de transmisión), tiempo de lectura del paquete, buffer de error (en caso de haber un error de entrada/salida). </p> <pre> <code> &NewLine;//<strong>d->name</strong>: nombre del dispositivo &NewLine;//<strong>65536</strong>: porción del paquete a ser capturado 65536 permite que el paquete completo sea capturado para distintos tipos de  MACs. &NewLine;//<strong>1</strong>: modo promiscuo distinto de 0 significa promiscuo) &NewLine;//<strong>1000</strong>: tiempo máximo de lectura de trama &NewLine;//<strong>errbuf</strong>: buffer de error (en caso de haber) &NewLine;if ((adhandle= pcap_open_live(d->name, 65536, 1, 1000, errbuf)) == NULL) { &NewLine;&Tab;fprintf(stderr,&quot;No es posible abrir el adaptador. %s no es soportado por NPcap&quot;, d->name); &NewLine;&Tab;/* limpiamos la lista de dispositivos */ &NewLine;&Tab;pcap_freealldevs(alldevs); &NewLine;&Tab;return -1; &NewLine;} </code> </pre> </li> <li> <p> Posteriormente iniciamos el proceso de captura de tramas mediante la función pcap_loop(), donde el primer argumento de la función identifica el descriptor del adaptador de red a ser usado, el segundo parámetro indica el número de tramas a ser capturaras (0 significa ciclo infinito de captura), el tercer argumento indica la función que será invocada para procesar la trama capturada y el cuarto argumento en caso de haber, indica un nombre de archivo usado para guardar la trama capturada. </p> <pre> <code> pcap_loop(adhandle, 15, packet_handler, (unsigned char *)dumpfile); </code> </pre> </li> <li> <p> El análisis del contenido de cada trama, tal como se vio en el punto anterior se hará dentro del cuerpo de la función especificada en el segundo argumento de la función pcap_loop. Esto es, en la función packet_handler, cuya sintaxis es la siguiente: </p> <pre> <code> void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data) </code> </pre> <p> cuyo primer argumento especifica el nombre del archivo donde se guardará la trama capturada (en caso de desear almacenar la trama capturada en un archivo), el segundo argumento contendrá el encabezado de la trama y el tercer argumento contendrá la trama en crudo, lista para ser analizada. Por ejemplo, si deseáramos imprimir de cada trama capturada su dirección MAC destino, dirección MAC origen y tipo de trama haríamos lo siguiente en el cuerpo de la función Packet_handler: </p> <pre> <code> &NewLine;void packet_handler(u_char * dumpfile, &NewLine;const struct pcap_pkthdr * header, &NewLine;const u_char * pkt_data){ &NewLine;&Tab;int j = 0, k = 0; &NewLine;&Tab;printf(&quot&quot;MAC destino:&quot&quot;); &NewLine;&Tab;for (j = 0; j < 6; j++) { &NewLine;&Tab;&Tab;printf(&quot&quot;%02X:&quot&quot;, pkt_data[j]); &NewLine;&Tab;} &NewLine;&Tab;printf(&quot&quot; MAC origen:&quot&quot;); &NewLine;&Tab;for (k = 6; k < 12; k++) { &NewLine;&Tab;&Tab;printf(&quot&quot;%02X: &quot&quot;, pkt_data[k]); &NewLine;&Tab;} &NewLine;&Tab;printf(&quot; &quot;); &NewLine;&Tab;unsigned short tipo = (pkt_data[12] * 256) + pkt_data[13]; &NewLine;&Tab;printf(&quot;Tipo: %d   %02X %02X &quot;, tipo, pkt_data[12], pkt_data[13]); &NewLine;} </code> </pre> </li> <li> <p> Para ver un ejemplo completo, da click en el siguiente enlace: <a href='http://148.204.58.221/axel/redesnp/sniffer/NPCAP/captura.c' >capturas.c</a > </p> </li> </ul> </section> <br /> <section> <h4>3.2.2 Rutinas para leer tramas desde un archivo</h4> <strong>Desde PCAP4J</strong> <br /><br /> <ul> <li> <p> Primero especificamos el tipo de archivo que será leído (.pcap), para ello ponemos la siguiente instrucción: </p> <pre> <code> private static final String PCAP_FILE_KEY = ReadPacketFile.class.getName() + &quot;.pcapFile&quot;; </code> </pre> </li> <li> <p> Después especificamos el nombre del archivo que será abierto para lectura (&quot;paquetes3.pcap&quot;), tal como se muestra a continuación: </p> <pre> <code> &NewLine;private static final String PCAP_FILE = &NewLine;System.getProperty(PCAP_FILE_KEY, &quot;paquetes3.pcap&quot;); </code> </pre> </li> <li> <p> A continuación, intentamos abrir el archivo mediante el método openOffline(), especificando el nombre del archivo, así como las unidades de medición de tiempo para la lectura del las tramas. Debemos considerar que quizá al intentar abrir el archivo podrían presentarse excepciones de Entrada/Salida </p> <pre> <code> &NewLine;try { &NewLine;&Tab;handle = Pcaps.openOffline(PCAP_FILE, TimestampPrecision.NANO); &NewLine;} catch (PcapNativeException e) { &NewLine;&Tab;handle = Pcaps.openOffline(PCAP_FILE); &NewLine;} </code> </pre> </li> <li> <p> Una vez abierto el archivo, comenzamos el procesamiento manual de cada trama contenida en él (en este ejemplo se intentarán leer hasta 32 tramas): </p> <pre> <code> &NewLine;for (int i = 0; i < 32; i++) { &NewLine;try { &NewLine;&Tab;byte[] packet = handle.getNextRawPacket(); &NewLine;&Tab;for(int j=0; j < packet.length; j++){ &NewLine;&Tab;&Tab;if(j%16==0) &NewLine;&Tab;&Tab;&Tab;System.out.println(&quot;&quot;); &NewLine;&Tab;&Tab;System.out.printf(&quot;%02X &quot;,packet[j]); &NewLine;&Tab;}//for &NewLine;&Tab;System.out.println(&quot;&quot;); &NewLine;}catch(Exception e){ &NewLine;&Tab;e.printStackTrace(); &NewLine;} </code> </pre> </li> <li> <p>Una vez procesadas las tramas procedemos a cerrar el archivo</p> <pre> <code> handle.close(); </code> </pre> </li> <li> <p> Para ver un ejemplo completo, da click en el siguiente enlace: <a href='http://148.204.58.221/axel/redesnp/sniffer/pcap4j/ReadPacketFile.java' >ReadPacketFile.java</a > </p> </li> </ul> <br /> <strong>Desde NPCAP</strong> <br /> <br /> <ul> <li> <p> Comenzamos por definir el nombre canónico del archivo que será leído y que contiene las tramas a ser analizadas desde NPCAP, en este ejemplo se llama &quot;paquetes3.pcap&quot;. </p> <pre> <code> &NewLine;#define RUTA &quot;D:\\Documentos\\Redespcap\\paquetes3.pcap&quot; </code> </pre> </li> <li> <p> Después debemos configurar la forma en que se intentará abrir el archivo, ya que NPCAP permite la apertura y procesamiento de archivos locales o remotos, para ello se usa la función pcap_createsrcstr( ), el primer argumento de esta función guardará la cadena con el nombre del archivo a ser abierto, el segundo argumento permite especificar el tipo de fuente de donde se hará la lectura de tramas (en este caso un archivo). El tercer argumento permitiría indicar el la dirección del host (en caso de que el análisis sea de manera remota, para este ejemplo es NULL porque el análisis es local), el cuarto argumento permite especificar el puerto remoto (en caso de que el análisis sea de manera remota, para este ejemplo es NULL porque el análisis es local), el quinto argumento permite definir la ruta (nombre canónico del archivo a ser abierto) y el último argumento permite definir un buffer donde se guardará el mensaje de error en caso de que exista al momento de intentar leer el recurso a ser leído. </p> <pre> <code> &NewLine;//<strong>source</strong>>: variable que guardará la ruta del archivo &NewLine;//<strong>PCAP_SRC_FILE</strong>>: deseamos abrir un archivo &NewLine;//<strong>NULL</strong>>:  host remoto &NewLine;//<strong>NULL</strong>>: puerto en el host remoto &NewLine;//<strong>RUTA</strong>>: nombre del archivo que deseamos abrir &NewLine;//<strong>errbuf</strong>>: buffer para guardar mensajes de error (de haber) &NewLine;if ( pcap_createsrcstr( source, PCAP_SRC_FILE, NULL, NULL, RUTA, errbuf ) != 0) { &NewLine;&Tab;fprintf(stderr,&quot;Error al crear la cadena del origen de datos&quot;); &NewLine;&Tab;return -1; &NewLine;} </code> </pre> </li> <li> <p> A continuación, intentaremos abrir el archivo para su lectura, para ello usaremos la función pcap_open( ), en los argumentos de esta función debemos especificar: el nombre del dispositivo, la porción del paquete a ser capturado, modo de apertura (promiscuo para escuchar todos los paquetes que pasen por el medio de transmisión), tiempo de lectura del paquete, si se hará alguna autenticación de usuario (solo para análisis remoto), buffer de error (en caso de haber un error de entrada/salida). Obtendremos como resultado un descriptor de tipo <strong>pcap_t</strong> </p> <pre> <code> &NewLine;//<strong>source</strong> nombre del dispositivo &NewLine;//<strong>65536</strong> porción del paquete a ser capturado 65536 permite que el paquete completo sea capturado para distintos tipos de  MACs. &NewLine;//<strong>PCAP_OPENFLAG_PROMISCUOUS</strong> modo promiscuo distinto de 0 significa promiscuo) &NewLine;//<strong>1000</strong> tiempo máximo de lectura de trama &NewLine;//<strong>NULL</strong> autenticación en el host remoto &NewLine;//<strong>errbuf</strong> buffer de error (en caso de haber) &NewLine;pcap_t *fp; &NewLine; if (( fp= (pcap_t * ) pcap_open( source, 65536, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf )) == NULL) { &NewLine;&Tab;fprintf(stderr,&quot;Unable to open the file %s&quot;, source); &NewLine;&Tab;return -1; &NewLine;} </code> </pre> </li> <li> <p> Ya abierto el archivo para su lectura, procedemos a leer las tramas, para ello usaremos la función pcap_loop ( ), donde el primer argumento de la función identifica el descriptor del dispositivo de lectura a ser usado, el segundo parámetro indica el número de tramas a ser capturaras (0 significa ciclo infinito de captura), el tercer argumento indica la función que será invocada para procesar la trama capturada y el cuarto argumento en caso de haber, indica un nombre de archivo usado para guardar la trama capturada. </p> <pre> <code> pcap_loop(fp, 0, dispatcher_handler, NULL); </code> </pre> </li> <li> <p> Después procedemos a dar cuerpo a la función dispatcher_handler que se encargará de procesar el contenido de cada trama leída </p> <pre> <code> void dispatcher_handler(u_char *temp1, &NewLine;const struct pcap_pkthdr *header, const u_char *pkt_data) </code> </pre> <p> El primer argumento de la función específica el nombre del archivo donde se guardará la trama capturada (en este caso ya se cuenta con un archivo, por lo que no se usará ese argumento), el segundo argumento contendrá el encabezado de la trama y el tercer argumento contendrá la trama en crudo, lista para ser analizada. Por ejemplo, si deseáramos imprimir de cada trama capturada su dirección MAC destino, dirección MAC origen y tipo de trama haríamos lo siguiente en el cuerpo de la función dispatcher_handler </p> <pre> <code> &NewLine;{ &NewLine;int j=0,k=0; &NewLine;printf(&quot;MAC destino:&quot;); &NewLine;for(j=0; j < 6; j++){ &NewLine;&Tab;printf(&quot;%02X:&quot;,pkt_data[j]); &NewLine;} &NewLine;printf(&quot; MAC origen:&quot;); &NewLine;for(k=6; k < 12; k++){ &NewLine;&Tab;printf(&quot;%02X: &quot;,pkt_data[k]); &NewLine;} &NewLine;printf(&quot; &quot;); &NewLine;unsigned short tipo = (pkt_data[12]*256)+pkt_data[13]; &NewLine;printf(&quot;Tipo: %d %02X %02X &quot;,tipo,pkt_data[12],pkt_data[13]); &NewLine;} </code> </pre> </li> <li> <p> Para ver un ejemplo completo, da click en el siguiente enlace: <a href='http://148.204.58.221/axel/redesnp/LLC/LLC.c'>LLC.C</a> </p> </li> </ul> </section> </section>",
        "recurso": "<h4>Acceso Acceso al controlador de la tarjeta de red en C</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='assets/data/NIC_Npcap.pdf' type='application/pdf'></object> </div> <br /> <br /> <h4 class='pt-5'>Acceso Acceso al controlador de la tarjeta de red en JAVA</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='assets/data/NIC_Pcap4J.pdf' type='application/pdf'></object> </div> <br /> <br /> <h4>Tutorial de instalacion de NPCAP en C</h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/SeqaCDfdzpo' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4>Tutorial de como listar Interfaces de red con NPCAP en C</h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/iEnKeBHVHqg' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4>Tutorial de como visualizar una trama utilizando NPCAP en C</h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/cFgc22wn1e0' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4>Tutorial de como analizar una trama utilizando NPCAP en C</h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/CprEysiSZJE' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4>Tutorial de como enviar tramas ethernet utilizando NPCAP en C</h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/o1XP_NobvtE' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4> Tutorial de como enviar archivos .PCAP por ethernet utilizando NPCAP en C </h4> <div class='embed-responsive embed-responsive-16by9'> <iframe width='100%' height='500px' src='https://www.youtube.com/embed/UtCxeBRJsZw' title='YouTube video player' frameborder='0' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen='' ></iframe> </div> <br /> <br /> <h4>Acceso Acceso al controlador de la tarjeta de red en C</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='http://148.204.58.221/axel/redesnp/sniffer/NPCAP/' type='text/html' ></object> </div> <h4 class='pt-5'>Acceso Acceso al controlador de la tarjeta de red en JAVA</h4> <div class='embed-responsive embed-responsive-16by9 diapos'> <object data='http://148.204.58.221/axel/redesnp/sniffer/pcap4j/' type='text/html' ></object> </div>"
      },
      {
        "seccion": 3.3,
        "titulo": "Estándar IEEE 802.3",
        "descripcionRecurso": "",
        "keywords": ["HDLC", "Encabezados", "Análisis de Trama"],
        "unidad": "<div class='embed-responsive embed-responsive-16by9 diapos'><object data='assets/data/HDLC_LLC.pdf' type='application/pdf'></object></div>",
        "recurso": "<h4>Est&aacute;ndar IEEE 802.3</h4><div class='embed-responsive embed-responsive-16by9 diapos'> <object data='assets/data/3_3_EstandarIEEE802.pdf' type='application/pdf' ></object> </div><br /><br />"
      },
      {
        "seccion": 3.4,
        "titulo": "Tecnologías de Control de Acceso al Medio",
        "descripcionRecurso": "",
        "keywords": ["Accesos, Medios compartidos, CSMA"],
        "unidad": "<div class='embed-responsive embed-responsive-16by9 diapos'><object data='assets/data/ControlAccesoMedio.pdf' type='application/pdf'></object></div>",
        "recurso": ""
      }
    ]
  },
  {
    "indice": 4,
    "titulo": "Capa de Internet",
    "imagen": "https://ruizhealytimes.com/wp-content/uploads/2020/12/Internet-velocidad-Foto-Archivo.jpg",
    "competencia": "Administra problemas entre redes IP con base en el direccionamiento IPv4 y los protocolos ARP, IP, ICMP, IGMP y de enrutamiento.  ",
    "keywords": ["Internet IP", "Enrutamiento IP", "ARP", "ICMP", "IGMP"],
    "contenido": [
      {
        "seccion": 4.1,
        "titulo": "Protocolo de Internet IP",
        "descripcionRecurso": "",
        "keywords": ["IPv4", "IPv6", "Encabezados", "Tramas"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 4.2,
        "titulo": "Enrutamiento IP",
        "descripcionRecurso": "",
        "keywords": ["Enrutamiento Estático", "Enrutamiento Dinámico"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 4.3,
        "titulo": "Protocolo de Resolución de Direcciones ARP",
        "descripcionRecurso": "",
        "keywords": ["ARP", "Tramas"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 4.4,
        "titulo": "Protocolo de Mensajes de Control de Internet ICMP ",
        "descripcionRecurso": "",
        "keywords": ["ICMP", "Tramas"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 4.5,
        "titulo": "Protocolo de Administración de Grupos de Internet (IGMP)",
        "descripcionRecurso": "",
        "keywords": ["IGMP", "DVMRP", "PIM", "MSDP"],
        "unidad": "",
        "recurso": ""
      }
    ]
  },
  {
    "indice": 5,
    "titulo": "Capa de Transporte",
    "imagen": "https://jaidoman.files.wordpress.com/2015/02/iot.png",
    "competencia": "Analiza los servicios de la capa de Transporte a partir de los protocolos TCP Y UDP para una comunicación confiable extremo a extremo.",
    "keywords": ["TCP", "UDP"],
    "contenido": [
      {
        "seccion": 5.1,
        "titulo": "Protocolo de Control de Transmisión TCP",
        "descripcionRecurso": "",
        "keywords": ["Encabezados TCP"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 5.2,
        "titulo": "Protocolo de Datagramas de Usuario UDP ",
        "descripcionRecurso": "",
        "keywords": ["Encabezados UDP"],
        "unidad": "",
        "recurso": ""
      },
      {
        "seccion": 5.3,
        "titulo": "Análisis de segmentos TCP y datagramas UDP",
        "descripcionRecurso": "",
        "keywords": ["Segmentos", "Datagramas"],
        "unidad": "",
        "recurso": ""
      }
    ]
  }
]
